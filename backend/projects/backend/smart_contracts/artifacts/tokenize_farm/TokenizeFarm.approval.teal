#pragma version 10
#pragma typetrack false

// smart_contracts.tokenize_farm.contract.TokenizeFarm.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1
    bytecblock 0x151f7c75 "is_initialized" "farm_name" "owner" "asset_id" "total_tokens_minted"
    // smart_contracts/tokenize_farm/contract.py:5
    // class TokenizeFarm(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@12
    pushbytess 0x82bb4979 0xe4773d9e 0x5ba22a84 0x22e4c5a0 0xff2ba5c5 0x55f0d38d 0x02bece11 // method "initialize_farm(string,uint64)string", method "get_farm_name()string", method "get_asset_id()uint64", method "get_total_minted()uint64", method "get_owner()address", method "update_farm_name(string)string", method "hello(string)string"
    txna ApplicationArgs 0
    match main_initialize_farm_route@5 main_get_farm_name_route@6 main_get_asset_id_route@7 main_get_total_minted_route@8 main_get_owner_route@9 main_update_farm_name_route@10 main_hello_route@11

main_after_if_else@14:
    // smart_contracts/tokenize_farm/contract.py:5
    // class TokenizeFarm(ARC4Contract):
    intc_0 // 0
    return

main_hello_route@11:
    // smart_contracts/tokenize_farm/contract.py:71
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/tokenize_farm/contract.py:5
    // class TokenizeFarm(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/tokenize_farm/contract.py:71
    // @abimethod()
    callsub hello
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_update_farm_name_route@10:
    // smart_contracts/tokenize_farm/contract.py:62
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/tokenize_farm/contract.py:5
    // class TokenizeFarm(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/tokenize_farm/contract.py:62
    // @abimethod()
    callsub update_farm_name
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_owner_route@9:
    // smart_contracts/tokenize_farm/contract.py:56
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_owner
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_total_minted_route@8:
    // smart_contracts/tokenize_farm/contract.py:50
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_total_minted
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_asset_id_route@7:
    // smart_contracts/tokenize_farm/contract.py:44
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_asset_id
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_farm_name_route@6:
    // smart_contracts/tokenize_farm/contract.py:38
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_farm_name
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_initialize_farm_route@5:
    // smart_contracts/tokenize_farm/contract.py:20
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/tokenize_farm/contract.py:5
    // class TokenizeFarm(ARC4Contract):
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    btoi
    // smart_contracts/tokenize_farm/contract.py:20
    // @abimethod()
    callsub initialize_farm
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@12:
    // smart_contracts/tokenize_farm/contract.py:5
    // class TokenizeFarm(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@14
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.tokenize_farm.contract.TokenizeFarm.initialize_farm(farm_name: bytes, asset_id: uint64) -> bytes:
initialize_farm:
    // smart_contracts/tokenize_farm/contract.py:20-25
    // @abimethod()
    // def initialize_farm(
    //     self,
    //     farm_name: String,
    //     asset_id: UInt64
    // ) -> String:
    proto 2 1
    // smart_contracts/tokenize_farm/contract.py:27
    // assert not self.is_initialized.value, "Farm already initialized"
    intc_0 // 0
    bytec_1 // "is_initialized"
    app_global_get_ex
    assert // check self.is_initialized exists
    !
    assert // Farm already initialized
    // smart_contracts/tokenize_farm/contract.py:29-30
    // # Store farm information
    // self.farm_name.value = farm_name
    bytec_2 // "farm_name"
    frame_dig -2
    app_global_put
    // smart_contracts/tokenize_farm/contract.py:31
    // self.asset_id.value = asset_id
    bytec 4 // "asset_id"
    frame_dig -1
    app_global_put
    // smart_contracts/tokenize_farm/contract.py:32
    // self.owner.value = Txn.sender
    bytec_3 // "owner"
    txn Sender
    app_global_put
    // smart_contracts/tokenize_farm/contract.py:33
    // self.is_initialized.value = True
    bytec_1 // "is_initialized"
    intc_1 // 1
    app_global_put
    // smart_contracts/tokenize_farm/contract.py:34
    // self.total_tokens_minted.value = UInt64(0)
    bytec 5 // "total_tokens_minted"
    intc_0 // 0
    app_global_put
    // smart_contracts/tokenize_farm/contract.py:36
    // return String("Farm tokenization initialized successfully")
    pushbytes "Farm tokenization initialized successfully"
    retsub


// smart_contracts.tokenize_farm.contract.TokenizeFarm.get_farm_name() -> bytes:
get_farm_name:
    // smart_contracts/tokenize_farm/contract.py:41
    // assert self.is_initialized.value, "Farm not initialized"
    intc_0 // 0
    bytec_1 // "is_initialized"
    app_global_get_ex
    assert // check self.is_initialized exists
    assert // Farm not initialized
    // smart_contracts/tokenize_farm/contract.py:42
    // return self.farm_name.value
    intc_0 // 0
    bytec_2 // "farm_name"
    app_global_get_ex
    assert // check self.farm_name exists
    retsub


// smart_contracts.tokenize_farm.contract.TokenizeFarm.get_asset_id() -> uint64:
get_asset_id:
    // smart_contracts/tokenize_farm/contract.py:47
    // assert self.is_initialized.value, "Farm not initialized"
    intc_0 // 0
    bytec_1 // "is_initialized"
    app_global_get_ex
    assert // check self.is_initialized exists
    assert // Farm not initialized
    // smart_contracts/tokenize_farm/contract.py:48
    // return self.asset_id.value
    intc_0 // 0
    bytec 4 // "asset_id"
    app_global_get_ex
    assert // check self.asset_id exists
    retsub


// smart_contracts.tokenize_farm.contract.TokenizeFarm.get_total_minted() -> uint64:
get_total_minted:
    // smart_contracts/tokenize_farm/contract.py:53
    // assert self.is_initialized.value, "Farm not initialized"
    intc_0 // 0
    bytec_1 // "is_initialized"
    app_global_get_ex
    assert // check self.is_initialized exists
    assert // Farm not initialized
    // smart_contracts/tokenize_farm/contract.py:54
    // return self.total_tokens_minted.value
    intc_0 // 0
    bytec 5 // "total_tokens_minted"
    app_global_get_ex
    assert // check self.total_tokens_minted exists
    retsub


// smart_contracts.tokenize_farm.contract.TokenizeFarm.get_owner() -> bytes:
get_owner:
    // smart_contracts/tokenize_farm/contract.py:59
    // assert self.is_initialized.value, "Farm not initialized"
    intc_0 // 0
    bytec_1 // "is_initialized"
    app_global_get_ex
    assert // check self.is_initialized exists
    assert // Farm not initialized
    // smart_contracts/tokenize_farm/contract.py:60
    // return self.owner.value
    intc_0 // 0
    bytec_3 // "owner"
    app_global_get_ex
    assert // check self.owner exists
    retsub


// smart_contracts.tokenize_farm.contract.TokenizeFarm.update_farm_name(new_farm_name: bytes) -> bytes:
update_farm_name:
    // smart_contracts/tokenize_farm/contract.py:62-63
    // @abimethod()
    // def update_farm_name(self, new_farm_name: String) -> String:
    proto 1 1
    // smart_contracts/tokenize_farm/contract.py:65
    // assert self.is_initialized.value, "Farm not initialized"
    intc_0 // 0
    bytec_1 // "is_initialized"
    app_global_get_ex
    assert // check self.is_initialized exists
    assert // Farm not initialized
    // smart_contracts/tokenize_farm/contract.py:66
    // assert Txn.sender == self.owner.value, "Only owner can update farm name"
    txn Sender
    intc_0 // 0
    bytec_3 // "owner"
    app_global_get_ex
    assert // check self.owner exists
    ==
    assert // Only owner can update farm name
    // smart_contracts/tokenize_farm/contract.py:68
    // self.farm_name.value = new_farm_name
    bytec_2 // "farm_name"
    frame_dig -1
    app_global_put
    // smart_contracts/tokenize_farm/contract.py:69
    // return String("Farm name updated successfully")
    pushbytes "Farm name updated successfully"
    retsub


// smart_contracts.tokenize_farm.contract.TokenizeFarm.hello(name: bytes) -> bytes:
hello:
    // smart_contracts/tokenize_farm/contract.py:71-72
    // @abimethod()
    // def hello(self, name: String) -> String:
    proto 1 1
    // smart_contracts/tokenize_farm/contract.py:74
    // return String("Hello, ") + name
    pushbytes "Hello, "
    frame_dig -1
    concat
    retsub
